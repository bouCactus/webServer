
diff --git a/src/session/HttpMethodProcessor.cpp b/src/session/HttpMethodProcessor.cpp
index 53a82c7..7229522 100644
--- a/src/session/HttpMethodProcessor.cpp
+++ b/src/session/HttpMethodProcessor.cpp
@@ -6,7 +6,7 @@
 
 #include <ctime>
 #include <string>
-
+#include "utilsFunction.hpp"
 #include "HttpRequest.hpp"
 #include "HttpResponse.hpp"
 #include "confAST.hpp"
@@ -19,40 +19,27 @@ bool resourceExists(Path& reqResource) { return (hfs::isExests(reqResource)); }
 HttpResponse createErrorPageResponse(const servers_it& serverConf,
                                      const int statCode) {
     HttpResponse res;
-    (void)serverConf;  // need to check about error page location : ask for
-                       // getErrorPage()
+    (void)(serverConf);
+    // i don't know how to use this getServerNames is it set of names, how
+    //serverConf->getServerNames();
+    std::string severName = "WebServer 0.1";
+    std::stringstream body;
+    std::string statusMessage = res.status.getStatusMessage(statCode);
+
     res.defaultErrorResponse(statCode);
+    res.appendHeader("Content-Type", "text/html");
+    body
+        << "<!DOCTYPE html><html><head><title>" << statCode << " "
+        << statusMessage << "</title></head><body><h1><center>" << statCode
+        << " " << statusMessage << "<hr>"
+        << "</center></h1><p><center>"
+        << severName
+        <<"</center></p></body></html>";
+    res.setBody(body.str());
+    res.appendHeader("Content-length", TO_STRING(res.getBodySize()));
     return (res);
 }
 

-std::string getTimeGMT() {
-    std::time_t now = std::time(NULL);
-    char buffer[80];
-    // Convert the time to a tm
-    std::tm* tm = std::gmtime(&now);
-    std::strftime(buffer, 80, "%a, %d %b %Y %T GMT", tm);  // Format the time
-    return (buffer);
-}
-
-std::string convertTimeToGMT(std::time_t time) {
-    struct tm lt;
-    char buffer[80];
-    std::string strbuffer;
-    localtime_r(&time, &lt);
-    std::strftime(buffer, 80, "%a, %d %b %Y %T GMT", &lt);  // Format the time
-    return (buffer);
-}
-
 std::string getType(Path& reqResource) {  // just temp
     std::map<std::string, std::string> types;
     std::map<std::string, std::string>::iterator it;
@@ -93,10 +80,10 @@ HttpResponse createRegularFileResponse(Path& reqResource,
     return (res);
 }
 Location getLocationOfFastCGIextension(Path& requestFile,
-                                  const servers_it& serverConf) {
+                                       const servers_it& serverConf) {
     if (!requestFile.has_extension()) {
-       LOG_THROW();
-	    throw std::exception();
+        LOG_THROW();
+        throw std::exception();
     }
     std::string requestFileExtension = requestFile.extension();
     std::string locationName = "." + requestFileExtension + "$";
@@ -105,11 +92,11 @@ Location getLocationOfFastCGIextension(Path& requestFile,
 }
 
 bool hasCGI(Path& reqResource, const servers_it& serverConf) {
-    try{
-      getLocationOfFastCGIextension(reqResource, serverConf);
-      return (true);
-    }catch(...){
-      return (false);
+    try {
+        getLocationOfFastCGIextension(reqResource, serverConf);
+        return (true);
+    } catch (...) {
+        return (false);
     }
 }
 
@@ -153,13 +140,14 @@ Location getLocation(const HttpRequest& req, servers_it& serverConf) {
 }
 
 bool isAutoIndexEnabled(const HttpRequest& req, const servers_it& serverConf) {
-  try{
-    std::string requestedLocationName = req.findlocationOfUrl(req.getPath(), serverConf);
-    Location location = serverConf->at(requestedLocationName);
-    return (location.isAutoIndex());
-  }catch(...){
-    return (false);
-  }
+    try {
+        std::string requestedLocationName =
+            req.findlocationOfUrl(req.getPath(), serverConf);
+        Location location = serverConf->at(requestedLocationName);
+        return (location.isAutoIndex());
+    } catch (...) {
+        return (false);
+    }
 }
 std::string listIndex(const HttpRequest& req, const servers_it& serverConf) {
     DIR* dir;
@@ -193,9 +181,10 @@ HttpResponse getAutoIndex(const HttpRequest& req,
     // res.appendHeader("Connection", "done");
     //++++++++++++++++++++
     responseBodyStream << "<!DOCTYPE html><head><title>"
-       << "Index of " << requestedPath.c_str() << "</title></head><body><h1>"
-       << requestedPath.c_str() << "</h1><hr><pre>"
-       << listIndex(req, serverConf) << "</pre></body></html>";
+                       << "Index of " << requestedPath.c_str()
+                       << "</title></head><body><h1>" << requestedPath.c_str()
+                       << "</h1><hr><pre>" << listIndex(req, serverConf)
+                       << "</pre></body></html>";
     res.setBody(responseBodyStream.str());
     std::cout << res.getBody() << std::endl;
     res.appendHeader("Content-length", TO_STRING(res.getBodySize()));
@@ -213,19 +202,17 @@ HttpResponse createDirectoryResponse(hfs::Path& reqResource,
         return (res);
     }
     indexPath = getindex(reqResource, req, serverConf);
-    std::cout << "go to the index: [" << indexPath.c_str() << "]" <<  std::endl;
+    std::cout << "go to the index: [" << indexPath.c_str() << "]" << std::endl;
     if (indexPath.empty()) {
         if (isAutoIndexEnabled(req, serverConf)) {
             // return (getAutoIndex(req, serverConf));
-            std::cout << "<---------------autoIndexEnalbed---------------->>>" << std::endl;
+            std::cout << "<---------------autoIndexEnalbed---------------->>>"
+                      << std::endl;
             res = getAutoIndex(req, serverConf);
-            std::cout << res.getStatus() << " " << res.getBody() << std::endl;
             return (res);
 
         } else {
-            std::cout << "auto index is off" << std::endl;
-            res.defaultErrorResponse(403);
-            return (res);  // remember to create res inside defaultError
+            return (createErrorPageResponse(serverConf,403));
         }
     } else {
         if (hasCGI(indexPath, serverConf)) {
@@ -235,43 +222,13 @@ HttpResponse createDirectoryResponse(hfs::Path& reqResource,
     }
 }

 HttpResponse HttpMethodProcessor::processGetRequest(HttpRequest& req,
                                                     servers_it& conf_S) {
     http::filesystem::Path requestedResource =
         req.getPathWRoot(req.getPath(), conf_S);
-    std::cout << "begin of processGet Path: " << requestedResource.c_str()
-              << std::endl;
-  
+
     if (!resourceExists(requestedResource)) {
+        std::cout << "generate error page for 404" << std::endl;
         return createErrorPageResponse(conf_S, 404);
     }
 
@@ -286,7 +243,7 @@ HttpResponse HttpMethodProcessor::processGetRequest(HttpRequest& req,
     std::cout << "prepar to inter file response" << std::endl;
     return (createRegularFileResponse(requestedResource, conf_S));
 }
-/*=============================================== delete request =================================*/
+/*=============================================== delete request * =================================*/
 HttpResponse delete_directory_recursive(const char* path,
                                         const servers_it& serverConf) {
     DIR* dir = opendir(path);
@@ -423,33 +380,34 @@ HttpResponse createDirectoryPostResponse(hfs::Path& reqResource,
 bool isLocationAllowUpload(const HttpRequest& req,
                            const servers_it& serverConf) {
     std::string location = req.findlocationOfUrl(req.getPath(), serverConf);
+    std::cout << "lcoation of post :" << location << std::endl;
     try {
         if (serverConf->at(location).isAllowed(POST)) return (true);
     } catch (std::exception&) {
     }
     return (false);
 }
-HttpResponse uploadFile(const hfs::Path& requestedResource,
-                        const HttpRequest& req, const servers_it& serverConf) {
+HttpResponse uploadFile(servers_it& serverConf, HttpRequest& req) {
     // if request get the file or check body
-    (void)requestedResource;
-    (void)req;
-    (void)serverConf;
     HttpResponse res;
-    res.defaultErrorResponse(201);
+    if (req.resourceIsCreatedSuccessfully()) {
+        res.defaultErrorResponse(201);
+    } else {
+        return (createErrorPageResponse(serverConf,400));
+    }
     return (res);
 }
 HttpResponse HttpMethodProcessor::processPostRequest(HttpRequest& req,
                                                      servers_it& conf_S) {
+    // If a location supports FastCGI then the request should be redirected to FastCGI.
     hfs::Path requestedResource = req.getPathWRoot(req.getPath(), conf_S);
     if (isLocationAllowUpload(req, conf_S)) {
-        return (uploadFile(requestedResource, req, conf_S));
+        return (uploadFile(conf_S, req));
     } else {
         if (!resourceExists(requestedResource)) {
             return (createErrorPageResponse(conf_S, 404));
         } else if (hfs::isDirectory(requestedResource)) {
-            return (
-                createDirectoryPostResponse(requestedResource, req, conf_S));
+            return (createDirectoryPostResponse(requestedResource, req, conf_S));
         } else if (hasCGI(requestedResource, conf_S)) {
             return executeCGIScriptAndGetResponse(requestedResource, req,
                                                   conf_S);
diff --git a/src/session/HttpRequest.cpp b/src/session/HttpRequest.cpp
index a3ffed7..3d045b6 100644
--- a/src/session/HttpRequest.cpp
+++ b/src/session/HttpRequest.cpp
@@ -1,147 +1,157 @@
 #include "HttpRequest.hpp"
+
 #include <fstream>
-HttpRequest::HttpRequest(void){
- std::cout << "Resquest: constructor not implemented yet" << std::endl;
-   _chunkSize = -1;
-   _contentLength = 0;
-   _headersProcessed = false;
+HttpRequest::HttpRequest(void) {
+    std::cout << "Resquest: constructor not implemented yet" << std::endl;
+    _chunkSize = -1;
+    _contentLength = 0;
+    _headersProcessed = false;
+    _resouceCreatedSyccessfully = false;
 };
 
-HttpRequest::~HttpRequest(void){
-  std::cout << "Resquest: destructor not implemented yet" << std::endl;
-  for (size_t i = 0; i < _parsed_parts.size(); ++i) {
-      _parsed_parts[i].fileStream->close();
-      delete _parsed_parts[i].fileStream;
-  }
+HttpRequest::~HttpRequest(void) {
+    std::cout << "Resquest: destructor not implemented yet" << std::endl;
+    for (size_t i = 0; i < _parsed_parts.size(); ++i) {
+        _parsed_parts[i].fileStream->close();
+        delete _parsed_parts[i].fileStream;
+    }
 }
 
-HttpRequest::HttpRequest(const HttpRequest &other){
-//   std::cout << "Resquest: copy consturctor not implemented yet" << std::endl;
-  (void)other;
+HttpRequest::HttpRequest(const HttpRequest& other) {
+    //   std::cout << "Resquest: copy consturctor not implemented yet" <<
+    //   std::endl;
+    (void)other;
 }
-HttpRequest &HttpRequest::operator = (const HttpRequest &other){
-  //std::cout << "Request: copy assignment not implemented yet" << std::endl;
-  (void)other;
-  return (*this);
-
+HttpRequest& HttpRequest::operator=(const HttpRequest& other) {
+    // std::cout << "Request: copy assignment not implemented yet" << std::endl;
+    (void)other;
+    return (*this);
 }
 
-
-std::string HttpRequest::getMethod(){
-  return (_method);
-}
-http::filesystem::Path HttpRequest::getPath()const {
-  return (_path);
+void HttpRequest::setResourceCreatedSuccessfully(bool status) {
+    _resouceCreatedSyccessfully = status;
 }
-std::string HttpRequest::getVersion(){
-  return (_version);
+bool HttpRequest::resourceIsCreatedSuccessfully() {
+    return (_resouceCreatedSyccessfully);
 }
 
-inline std::string& rtrim(std::string& s){
+std::string HttpRequest::getMethod() { return (_method); }
+http::filesystem::Path HttpRequest::getPath() const { return (_path); }
+std::string HttpRequest::getVersion() { return (_version); }
+
+inline std::string& rtrim(std::string& s) {
     s.erase(s.find_last_not_of(" \t\n\r\f\v") + 1);
     return s;
 }
 
 // trim from beginning of string (left)
-inline std::string& ltrim(std::string& s){
+inline std::string& ltrim(std::string& s) {
     s.erase(0, s.find_first_not_of(" \t\n\r\f\v"));
     return s;
 }
 
 // trim from both ends of string (right then left)
-inline std::string& trim(std::string& s){
-    return ltrim(rtrim(s));
-}
-
-void HttpRequest::processRequestHeaders(){
-  std::size_t endOfHeaders = _requestBuffer.find("\r\n\r\n");
-  if (endOfHeaders != std::string::npos){
-    std::string headersData = _requestBuffer.substr(0, endOfHeaders);
-    _requestBuffer = _requestBuffer.substr(endOfHeaders+4, _requestBuffer.size());
-
-    std::istringstream iss(headersData);
-    std::string line;
-
-    // Parse the request line
-    std::getline(iss, line);
-    std::istringstream lineStream(line);
-    std::string path;
-    lineStream >> _method >> path >> _version;
-    _path.setPath(path);
-    // Parse the headers
-    while (std::getline(iss, line) && !line.empty()) {
-      // Split each header line into key and value
-      std::size_t colonPos = line.find(':');
-      if (colonPos != std::string::npos) {
-	      std::string key = line.substr(0, colonPos);
-	      std::string value = line.substr(colonPos + 1);
-	      std::string whitespaces (" \t\f\v\n\r");
-	      // Trim leading and trailing whitespaces from the key and value
-	      trim(value);
-	      trim(key);
-
-	      // Store the header in the headers map
-	      headers[key] = value;
-      }
+inline std::string& trim(std::string& s) { return ltrim(rtrim(s)); }
+
+void HttpRequest::processRequestHeaders() {
+    std::size_t endOfHeaders = _requestBuffer.find("\r\n\r\n");
+    if (endOfHeaders != std::string::npos) {
+        std::string headersData = _requestBuffer.substr(0, endOfHeaders);
+        _requestBuffer =
+            _requestBuffer.substr(endOfHeaders + 4, _requestBuffer.size());
+
+        std::istringstream iss(headersData);
+        std::string line;
+
+        // Parse the request line
+        std::getline(iss, line);
+        std::istringstream lineStream(line);
+        std::string path;
+        lineStream >> _method >> path >> _version;
+        _path.setPath(path);
+        // Parse the headers
+        while (std::getline(iss, line) && !line.empty()) {
+            // Split each header line into key and value
+            std::size_t colonPos = line.find(':');
+            if (colonPos != std::string::npos) {
+                std::string key = line.substr(0, colonPos);
+                std::string value = line.substr(colonPos + 1);
+                std::string whitespaces(" \t\f\v\n\r");
+                // Trim leading and trailing whitespaces from the key and value
+                trim(value);
+                trim(key);
+
+                // Store the header in the headers map
+                headers[key] = value;
+            }
+        }
+        _headersProcessed = true;
     }
-    _headersProcessed = true;
-  }
 }
 
 std::ofstream* createFile(const std::string& name) {
-    std::ofstream* fileStream = new std::ofstream(name.c_str(), std::ios::binary | std::ios::app);
+    std::ofstream* fileStream =
+        new std::ofstream(name.c_str(), std::ios::binary | std::ios::app);
     if (!fileStream || !fileStream->is_open()) {
-        std::cerr << "Failed to open file for storing chunked data." << std::endl;
-        if (fileStream) delete fileStream; // Cleanup the dynamically allocated stream before returning NULL
+        std::cerr << "Failed to open file for storing chunked data."
+                  << std::endl;
+        if (fileStream)
+            delete fileStream;  // Cleanup the dynamically allocated stream
+                                // before returning NULL
         return NULL;
     }
     return fileStream;
 }
 
 bool HttpRequest::prepareFileForPostRequest() {
-        // Get the location for file upload
-        FormDataPart part;
-        part.name = "chunkData";
-        part.filename = "chunkData.txt"; // You can modify this to get it from contentType
-
-        part.fileStream = createFile(part.filename);
-        if (part.fileStream == NULL)
-          return (false);
-        _parsed_parts.push_back(part); // Store the part for later use
-        return true;
+    // Get the location for file upload
+    FormDataPart part;
+    part.name = "chunkData";
+    part.filename =
+        "chunkData.txt";  // You can modify this to get it from contentType
+
+    part.fileStream = createFile(part.filename);
+    if (part.fileStream == NULL) {
+        setResourceCreatedSuccessfully(false);
+        return (false);
+    }
+    _parsed_parts.push_back(part);  // Store the part for later use
+    setResourceCreatedSuccessfully(true);
+    return true;
 }
 
 void HttpRequest::closeFile() {
-  if (!_parsed_parts.empty()) {
-       FormDataPart part = _parsed_parts.back();
-      part.fileStream->close();
-  }
+    if (!_parsed_parts.empty()) {
+        FormDataPart part = _parsed_parts.back();
+        part.fileStream->close();
+    }
 }
 
 bool HttpRequest::storeChunkToFile(std::string& chunk) {
-  if (_parsed_parts.empty()) {
-       if (!prepareFileForPostRequest())
-          return false;
-  }
-  FormDataPart& part = _parsed_parts.back(); // Get the last file stream
-  (*part.fileStream) << chunk; // Write the chunk to the file
-  return true;
+    if (_parsed_parts.empty()) {
+        if (!prepareFileForPostRequest()) {
+            setResourceCreatedSuccessfully(false);
+            return false;
+        }
+    }
+    FormDataPart& part = _parsed_parts.back();  // Get the last file stream
+    (*part.fileStream) << chunk;                // Write the chunk to the file
+    setResourceCreatedSuccessfully(true);
+    return true;
 }
-  
-
 
 bool HttpRequest::parseChunkedEncoding() {
     while (!_requestBuffer.empty()) {
         if (_chunkSize == static_cast<size_t>(-1)) {
             size_t lineEnd = _requestBuffer.find("\r\n");
-            if (lineEnd == std::string::npos)
-                break;
+            if (lineEnd == std::string::npos) break;
 
             std::string chunkSizeStr = _requestBuffer.substr(0, lineEnd);
 
             char* endPtr;
             _chunkSize = std::strtoul(chunkSizeStr.c_str(), &endPtr, 16);
-            if (endPtr != chunkSizeStr.c_str() + lineEnd) // Check if the parsing was successful
+            if (endPtr != chunkSizeStr.c_str() +
+                              lineEnd)  // Check if the parsing was successful
                 break;
 
             _requestBuffer.erase(0, lineEnd + 2);
@@ -177,7 +187,8 @@ FormDataPart parseMultipartFormData(std::string& headers) {
 
             size_t filename_start = line.find("filename=\"", name_end) + 10;
             size_t filename_end = line.find("\"", filename_start);
-            part.filename = line.substr(filename_start, filename_end - filename_start);
+            part.filename =
+                line.substr(filename_start, filename_end - filename_start);
         } else if (line.substr(0, 13) == "Content-Type:") {
             size_t content_type_start = line.find(":") + 2;
             part.content_type = line.substr(content_type_start);
@@ -186,21 +197,20 @@ FormDataPart parseMultipartFormData(std::string& headers) {
     return part;
 }
 
-bool HttpRequest::prepareFileForPostRequest(FormDataPart& part){
+bool HttpRequest::prepareFileForPostRequest(FormDataPart& part) {
     std::string fileName;
-    
-        
-        fileName = part.name;// for now replace with filename
-        // TODO
-        // check if file or just text 
-        part.fileStream = createFile(fileName);
-        if (!part.fileStream)
-          return (false);
-   
+
+    fileName = part.name;  // for now replace with filename
+    // TODO
+    // check if file or just text
+    part.fileStream = createFile(fileName);
+    if (!part.fileStream) return (false);
+
     return (true);
 }
 
-void HttpRequest::parseMultipartFileContent(const std::string& content, size_t start, size_t end) {
+void HttpRequest::parseMultipartFileContent(const std::string& content,
+                                            size_t start, size_t end) {
     if (start >= content.size() || end > content.size() || start > end) {
         // Invalid positions, handle the error or return early
         return;
@@ -219,54 +229,60 @@ bool HttpRequest::parseBoundaryChunk(std::string& boundary) {
 
     size_t nextBoundaryPos = _requestBuffer.find(boundaryPrefix);
     size_t endBoundaryPos = _requestBuffer.find(boundarySuffix);
-    while (nextBoundaryPos != std::string::npos || endBoundaryPos != std::string::npos) {
+    while (nextBoundaryPos != std::string::npos ||
+           endBoundaryPos != std::string::npos) {
         if (nextBoundaryPos == 0) {
             size_t endOfHeaders = _requestBuffer.find("\r\n\r\n");
-            if (endOfHeaders == std::string::npos)
-                return false;
+            if (endOfHeaders == std::string::npos) return false;
 
-            std::string removeBoundary = _requestBuffer.substr(boundaryPrefixLength, endOfHeaders - boundaryPrefixLength);
+            std::string removeBoundary = _requestBuffer.substr(
+                boundaryPrefixLength, endOfHeaders - boundaryPrefixLength);
             FormDataPart part = parseMultipartFormData(removeBoundary);
-            _requestBuffer.erase(0, endOfHeaders + 4); // 4 = endOfHeaders.length();
+            _requestBuffer.erase(
+                0, endOfHeaders + 4);  // 4 = endOfHeaders.length();
             prepareFileForPostRequest(part);
             _parsed_parts.push_back(part);
-        }else if (nextBoundaryPos != std::string::npos){ 
-          parseMultipartFileContent(_requestBuffer, 0, nextBoundaryPos - 2);// 2 for remove "\r\n"
-          closeFile();
-          _requestBuffer.erase(0, nextBoundaryPos);
-        }else if (endBoundaryPos != std::string::npos) {
-          parseMultipartFileContent(_requestBuffer, 0, endBoundaryPos - 4); // 4 for remove "--\r\n"
-          closeFile();
+        } else if (nextBoundaryPos != std::string::npos) {
+            parseMultipartFileContent(
+                _requestBuffer, 0, nextBoundaryPos - 2);  // 2 for remove "\r\n"
+            closeFile();
+            _requestBuffer.erase(0, nextBoundaryPos);
+        } else if (endBoundaryPos != std::string::npos) {
+            parseMultipartFileContent(
+                _requestBuffer, 0,
+                endBoundaryPos - 4);  // 4 for remove "--\r\n"
+            closeFile();
             _requestBuffer.clear();
             return true;
         }
         nextBoundaryPos = _requestBuffer.find(boundaryPrefix);
         endBoundaryPos = _requestBuffer.find(boundarySuffix);
     }
-    if (!_requestBuffer.empty()){
+    if (!_requestBuffer.empty()) {
         parseMultipartFileContent(_requestBuffer, 0, _requestBuffer.length());
         _requestBuffer.clear();
     }
     return false;
 }
 
-bool HttpRequest::processRequestBodyContent(){
-  const std::string& contentLength = headers["Content-Length"];
-  const std::string& transferEncoding = headers["Transfer-Encoding"];
-  const std::string& contentType = headers["Content-Type"];
-  const std::string boundaryPrefix = "boundary=";
-
+bool HttpRequest::processRequestBodyContent() {
+    const std::string& contentLength = headers["Content-Length"];
+    const std::string& transferEncoding = headers["Transfer-Encoding"];
+    const std::string& contentType = headers["Content-Type"];
+    const std::string boundaryPrefix = "boundary=";
 
     if (transferEncoding == "chunked") {
         // Process chunked data
-        std::cout << "|+|==============chunked==================|+|" << std::endl;
+        std::cout << "|+|==============chunked==================|+|"
+                  << std::endl;
         return parseChunkedEncoding();
-    }else if (!contentLength.empty()) {
+    } else if (!contentLength.empty()) {
         _contentLength += _requestBuffer.size();
         size_t boundaryPos = contentType.find(boundaryPrefix);
         if (boundaryPos != std::string::npos) {
             // Process boundary
-            std::string boundary = contentType.substr(boundaryPos + boundaryPrefix.size());
+            std::string boundary =
+                contentType.substr(boundaryPos + boundaryPrefix.size());
             return parseBoundaryChunk(boundary);
         }
 
@@ -275,21 +291,19 @@ bool HttpRequest::processRequestBodyContent(){
             _requestBuffer.clear();
         }
         // Do something when body overflow
-        return (_contentLength == static_cast<size_t>(std::stoi(contentLength)));
-    } 
+        return (_contentLength ==
+                static_cast<size_t>(std::stoi(contentLength)));
+    }
     // No content or unsupported encoding
     return true;
-    
 }
 
-
 bool HttpRequest::parseRequest(const std::string rawData) {
     _requestBuffer += rawData;
 
     if (!_headersProcessed) {
         // Process request headers only if they haven't been parsed yet
         processRequestHeaders();
-        
     }
     // Process the request body
     return processRequestBodyContent();
@@ -298,7 +312,7 @@ bool HttpRequest::parseRequest(const std::string rawData) {
 std::vector<std::string> getAllDirectories(const std::string& path) {
     std::vector<std::string> directories;
     std::string::size_type pos = 0;
-    
+
     // If the path starts with a slash, add it as the root directory
     if (!path.empty() && path[0] == '/') {
         directories.push_back("/");
@@ -345,36 +359,35 @@ std::string HttpRequest::findlocationOfUrl(const hfs::Path& path,
         return (rootDir);
 
     } catch (...) {
-        return ("") ;
+        return ("");
     }
 }
 
-hfs::Path HttpRequest::addRoot(const hfs::Path&		path,
-			       const std::string&	location,
-			       const servers_it& conf)const {
-  const std::string   separator = "/";
-  const std::string   rootDir	  = "/";
-  size_t	      pos = (location == rootDir) ? 0 : location.size();
-  value_t	      root;
-
-  std::string	pathStr = path.c_str();
- 
-  try{
-    root = conf->at(location).getRoot();
-  }catch(std::exception&){
-    std::cout << "page 500" << std::endl;
-  }
-  hfs::Path	newPath(path);
-  newPath.setPath(pathStr.replace(0, pos, root));
-
-  return newPath;
-}
+hfs::Path HttpRequest::addRoot(const hfs::Path& path,
+                               const std::string& location,
+                               const servers_it& conf) const {
+    const std::string separator = "/";
+    const std::string rootDir = "/";
+    size_t pos = (location == rootDir) ? 0 : location.size();
+    value_t root;
 
-hfs::Path HttpRequest::getPathWRoot(const hfs::Path& path, const servers_it& conf)const {
-  std::cout << path.c_str() << std::endl;
-  value_t	root = findlocationOfUrl(path, conf);
-  std::cout << "root: " << root << std::endl;
-  return addRoot(path, root, conf);
-}
+    std::string pathStr = path.c_str();
 
+    try {
+        root = conf->at(location).getRoot();
+    } catch (std::exception&) {
+        std::cout << "page 500" << std::endl;
+    }
+    hfs::Path newPath(path);
+    newPath.setPath(pathStr.replace(0, pos, root));
+
+    return newPath;
+}
 
+hfs::Path HttpRequest::getPathWRoot(const hfs::Path& path,
+                                    const servers_it& conf) const {
+    std::cout << path.c_str() << std::endl;
+    value_t root = findlocationOfUrl(path, conf);
+    std::cout << "root: " << root << std::endl;
+    return addRoot(path, root, conf);
+}
diff --git a/src/session/HttpResponse.cpp b/src/session/HttpResponse.cpp
index a80ebfc..4990227 100644
--- a/src/session/HttpResponse.cpp
+++ b/src/session/HttpResponse.cpp
@@ -2,6 +2,7 @@
 #include "HttpStatusCodes.hpp"
 #include "fileSystem.hpp"
 #include <sstream>
+#include "utilsFunction.hpp"
 
 HttpResponse::~HttpResponse(void){
 //   std::cout << "response: destructor not implemented yet" << std::endl;
@@ -84,26 +85,14 @@ std::string HttpResponse::getHeaders(){
 }
 
 void HttpResponse::defaultErrorResponse(int status){ 
-   std::stringstream	st;
-   std::string		body;
   this->setStatus(status);
   this->setVersion("HTTP/1.1");
-  this->appendHeader("Content-Type","text/html");
-
-  
-  st << "<!DOCTYPE html><html><head><title>"
-     << status << " " << this->status.getStatusMessage(status)
-     << "</title></head><body><h1><center>"
-     << status << " "
-     << this->status.getStatusMessage(status)
-     << "<hr>"
-     << "</center></h1><p><center>webServer/0.01</center></p></body></html>";
-  body = st.str();
-  this->appendHeader("Content-length", TO_STRING(body.size())); 
-  this->setBody(body);
+  this->appendHeader("Date", getTimeGMT());
+  this->appendHeader("Connection", "keep-alive");
 }
 
 
+
 void HttpResponse::writeHeader(int statu, Smap_t& header){
   Smap_t::iterator	mapIt;
   setVersion("HTTP/1.1");
